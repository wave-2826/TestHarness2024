// RobotBuilder Version: 5.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

// ROBOTBUILDER TYPE: Subsystem.

package frc.robot.subsystems;

import frc.robot.commands.*;
import frc.robot.oi.ShuffleboardContent;
import edu.wpi.first.wpilibj.livewindow.LiveWindow;
import edu.wpi.first.wpilibj2.command.SubsystemBase;

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS
import edu.wpi.first.wpilibj.motorcontrol.MotorController;
import edu.wpi.first.wpilibj.motorcontrol.PWMSparkMax;
import com.revrobotics.CANSparkMax;
import com.revrobotics.CANSparkMaxLowLevel.MotorType;
import com.revrobotics.SparkMaxPIDController;
import com.revrobotics.RelativeEncoder;

/**
 *
 */
public class TestMotors extends SubsystemBase {
    private CANSparkMax motorController1;
    private CANSparkMax motorController2;
    private CANSparkMax motorController3;
    private CANSparkMax motorController4;
    private RelativeEncoder encoder1;
    private RelativeEncoder encoder2;
    private RelativeEncoder encoder3;
    private RelativeEncoder encoder4;
    
    private SparkMaxPIDController pidController1;
    private SparkMaxPIDController pidController3;
    private SparkMaxPIDController pidController4;
    public double m1_kP, m1_kI, m1_kD, m1_kIz, m1_kFF, kMaxOutput, kMinOutput, maxRPM;
    public double m3_kP, m3_kI, m3_kD, m3_kIz, m3_kFF;
    public double m4_kP, m4_kI, m4_kD, m4_kIz, m4_kFF;
    public double kMaxAcceleration, kMaxVelocity;
    

    /**
    *
    */
    public TestMotors() {
        motorController1 = new CANSparkMax(10, MotorType.kBrushless);
        motorController1.setInverted(false);

        motorController2 = new CANSparkMax(13, MotorType.kBrushless);
        motorController2.setInverted(false);

        motorController3 = new CANSparkMax(54, MotorType.kBrushless);
        motorController3.setInverted(false);

        motorController4 = new CANSparkMax(57, MotorType.kBrushless);
        motorController4.setInverted(false);

        encoder1 = motorController1.getEncoder();
        encoder2 = motorController2.getEncoder();
        encoder3 = motorController3.getEncoder();
        encoder4 = motorController4.getEncoder();

        motorController1.restoreFactoryDefaults();
        motorController3.restoreFactoryDefaults();
        motorController4.restoreFactoryDefaults();

        pidController1 = motorController1.getPIDController();
        pidController3 = motorController3.getPIDController();
        pidController4 = motorController4.getPIDController();

        // PID coeffiecients
        m1_kP = 6e-5; 
        m1_kI = 0;
        m1_kD = 0; 
        m1_kIz = 0; 
        m1_kFF = 0.000175; 

        m3_kP = 6e-5; 
        m3_kI = 0;
        m3_kD = 0; 
        m3_kIz = 0; 
        m3_kFF = 0.000175; 

        m4_kP = 0.5; 
        m4_kI = 0;
        m4_kD = 0; 
        m4_kIz = 0; 
        m4_kFF = 0; 

        kMaxOutput = 1; 
        kMinOutput = -1;
        maxRPM = 5700;

        kMaxAcceleration = 868;
        kMaxVelocity = 5000;

        // set PID coefficients for motor 1
        pidController1.setP(m1_kP);
        pidController1.setI(m1_kI);
        pidController1.setD(m1_kD);
        pidController1.setIZone(m1_kIz);
        pidController1.setFF(m1_kFF);
        pidController1.setOutputRange(kMinOutput, kMaxOutput);

        // can set PID values with a gain & a slot ID
        pidController1.setSmartMotionMaxAccel(kMaxAcceleration, 0);
        pidController1.setSmartMotionMaxVelocity(kMaxVelocity, 0);

        // set PID coefficients for motor 3
        pidController3.setP(m3_kP);
        pidController3.setI(m3_kI);
        pidController3.setD(m3_kD);
        pidController3.setIZone(m3_kIz);
        pidController3.setFF(m3_kFF);
        pidController3.setOutputRange(kMinOutput, kMaxOutput);

        // set PID coefficients for motor 4
        pidController4.setP(m4_kP);
        pidController4.setI(m4_kI);
        pidController4.setD(m4_kD);
        pidController4.setIZone(m4_kIz);
        pidController4.setFF(m4_kFF);
        pidController4.setOutputRange(kMinOutput, kMaxOutput);

        // pidController4.getSma
   

        ShuffleboardContent.initMotorShuffleboard(motorController1);

    }

    /**
     * PID velocity control setter for motor 1
     * 
     * @param velocity in rpm
     */
    public void SetMotor1Velocity(double velocity) {
        pidController1.setReference(velocity, CANSparkMax.ControlType.kVelocity);
    }

    public void SetMotor1SmartVelocity(double velocity){
        pidController1.setReference(velocity, CANSparkMax.ControlType.kSmartVelocity);
    }

    /**
     * PID position control setter for motor 1
     * 
     * @param position in rotations
     */
    public void SetMotor1Position(double position) {
        pidController1.setReference(position, CANSparkMax.ControlType.kPosition);
    }

    /**
     * PID velocity control setter for motor 3
     * 
     * @param velocity in rpm
     */
    public void SetMotor3Velocity(double velocity) {
        pidController3.setReference(velocity, CANSparkMax.ControlType.kVelocity);
    }

    /**
     * PID position control setter for motor 3
     * 
     * @param position in rotations
     */
    public void SetMotor3Position(double position) {
        pidController3.setReference(position, CANSparkMax.ControlType.kPosition);
    }

    /**
     * PID velocity control setter for motor 4
     * 
     * @param velocity in rpm
     */
    public void SetMotor4Velocity(double velocity) {
        pidController4.setReference(velocity, CANSparkMax.ControlType.kVelocity);
    }

    /**
     * PID position control setter for motor 4
     * 
     * @param position in rotations
     */
    public void SetMotor4Position(double position) {
        pidController4.setReference(position, CANSparkMax.ControlType.kPosition);
    }

    @Override
    public void periodic() {
        // This method will be called once per scheduler run

    }

    @Override
    public void simulationPeriodic() {
        // This method will be called once per scheduler run when in simulation

    }

    // Put methods for controlling this subsystem
    // here. Call these from Commands.

    public void SetMotor1Speed(double speed) {
        motorController1.set(speed);
    }

    public double GetMotor1Position() {
        return motorController1.getEncoder().getPosition();
    }

    public double GetMotor1Velocity() {
        return motorController1.getEncoder().getVelocity();
    }
    
    public void SetMotor2Speed(double speed) {
        motorController2.set(speed);
    }

    public double GetMotor2Position() {
        return motorController2.getEncoder().getPosition();
    }

    public double GetMotor2Velocity() {
        return motorController2.getEncoder().getVelocity();
    }

    public void SetMotor3Speed(double speed) {
        motorController3.set(speed);
    }

    public double GetMotor3Position() {
        return motorController3.getEncoder().getPosition();
    }

    public double GetMotor3Velocity() {
        return motorController3.getEncoder().getVelocity();
    }

    public void SetMotor4Speed(double speed) {
        motorController4.set(speed);
    }

    public double GetMotor4Position() {
        return motorController4.getEncoder().getPosition();
    }

    public double GetMotor4Velocity() {
        return motorController4.getEncoder().getVelocity();
    }

    public void resetMotor1Position() {
        encoder1.setPosition(0);
    }

    public void resetMotor4Position() {
        // encoder4.
        encoder4.setPosition(0);
    }

}
